from datetime import datetime
from typing import Any
from typing import Optional

from oas_tools.cli_gen.layout_types import CommandNode
from oas_tools.cli_gen.utils import to_snake_case
from oas_tools.types import OasField
from oas_tools.utils import map_operations

NL = "\n"
SHEBANG = """\
#!/usr/bin/env python3
"""
COPYRIGHT = f"""\
# Copyright {datetime.now().year}
#
# This code was generated by the oas-tools CLI generator, DO NOT EDIT
#
"""


class Generator:
    def __init__(self, package_name: str, oas: dict[str, Any]):
        self.package_name = package_name
        self.operations = map_operations(oas.get(OasField.PATHS, {}))
        self.models = oas.get(OasField.COMPONENTS, {}).get(OasField.SCHEMAS, {})
        self.default_host = "http://acme.com"

    def shebang(self) -> str:
        """Returns the shebang line that goes at the top of each file."""
        return SHEBANG

    def copyright(self) -> str:
        """Returns the copyright header near the top of each file."""
        return COPYRIGHT

    def standard_imports(self) -> str:
        return f"""
from enum import Enum
from typing import Optional
from typing_extensions import Annotated

import typer

from {self.package_name} import _arguments as _a
"""

    def subcommand_imports(self, subcommands: list[CommandNode]) -> str:
        return NL.join(
            f"from {self.package_name}.{to_snake_case(n.identifier)} import app as {to_snake_case(n.identifier)}"
            for n in subcommands
        )

    def app_definition(self, node: CommandNode) -> str:
        result = f"""

app = typer.Typer(no_args_is_help=True, help="{node.description}")
"""
        for child in node.subcommands():
            result += f"""\
app.add_typer({to_snake_case(child.identifier)}, name="{child.command}")
"""

        return result

    def main(self) -> str:
        return """

if __name__ == "__main__":
    app()
"""

    def op_short_help(self, operation: dict[str, Any]) -> str:
        """Gets the short help for the operation."""
        summary = operation.get(OasField.SUMMARY)
        if summary:
            return summary

        description = operation.get(OasField.DESCRIPTION, "")
        return description.split(". ")[0]

    def op_long_help(self, operation: dict[str, Any]) -> str:
        text = operation.get(OasField.DESCRIPTION) or operation.get(OasField.SUMMARY) or ""
        # TODO: sanitize  NL's, long text, etc
        return text

    def op_infra_arguments(self, operation: dict[str, Any]) -> list[str]:
        # NOTE: other args may be appended later, so keeping as list
        args = [
            f'_api_host: _a.ApiHostOption = "{self.default_host}"',
            '_api_key: _a.ApiKeyOption = None',
            '_api_timeout: _a.ApiTimeoutOption = 5',
            '_log_level: _a.LogLevelOption = _a.LogLevel.WARN',
            '_out_fmt: _a.OutputFormatOption = _a.OutputFormat.TABLE',
            '_out_style: _a.OutputStyleOption = _a.OutputStyle.ALL',
        ]
        return args

    def schema_to_type(self, schema: str, fmt: Optional[str]) -> str:
        """
        Gets the base Python type for simple schema types.

        The fmt is really the "format" field, but renamed to avoid masking builtin.
        """
        if schema == "boolean":
            return "bool"
        if schema == "integer":
            return "int"
        if schema == "numeric":
            return "float"
        if schema == "string":
            if fmt == "date-time":
                return "datetime"
            # TODO: uuid
            return "str"

        message = f"Unable to determine type for {schema}"
        if fmt:
            message += f" ({fmt})"
        raise ValueError(message)

    def op_params(self, operation: dict[str, Any], location: str) -> list[dict[str, Any]]:
        """
        Gets a complete list of operation parameters matching location.
        """
        params = []
        # NOTE: start with "higher level" path params, since they're more likely to be required
        for item in operation.get(OasField.X_PATH_PARAMS) or []:
            if item.get(OasField.IN) != location:
                continue
            params.append(item)
        for item in operation.get(OasField.PARAMS) or []:
            if item.get(OasField.IN) != location:
                continue
            params.append(item)
        return params

    def op_param_to_argument(self, param: dict[str, Any], allow_required: bool) -> str:
        """
        Converts a parameter into a typer argument.
        """
        var_name = to_snake_case(param.get(OasField.NAME))
        description = param.get(OasField.DESCRIPTION) or ""
        required = param.get(OasField.REQUIRED, False)
        schema = param.get(OasField.SCHEMA, {})
        schema_default = schema.get(OasField.DEFAULT)
        schema_type = schema.get(OasField.TYPE)
        schema_format = schema.get(OasField.FORMAT)
        arg_type = self.schema_to_type(schema_type, schema_format)

        typer_args = []
        if arg_type in ("int", "float"):
            schema_min = schema.get(OasField.MIN)
            if schema_min is not None:
                typer_args.append(f"min={schema_min}")
            schema_max = schema.get(OasField.MAX)
            if schema_max is not None:
                typer_args.append(f"max={schema_max}")
        if allow_required and required and schema_default is None:
            typer_type = 'typer.Argument'
            typer_args.append('show_default=False')
            arg_default = ""
        else:
            typer_type = 'typer.Option'
            if schema_default is None:
                arg_type = f"Optional[{arg_type}]"
                arg_default = " = None"
                typer_args.append('show_default=False')
            else:
                if arg_type in ("str", "datetime"):
                    arg_default = f' = "{schema_default}"'
                else:
                    arg_default = f" = {schema_default}"
        typer_args.append(f'help="{description}"')
        comma = ', '

        return f'{var_name}: Annotated[{arg_type}, {typer_type}({comma.join(typer_args)})]{arg_default}'

    def op_path_arguments(self, operation: dict[str, Any]) -> list[str]:
        """
        Converts all path parameters into typer arguments.
        """
        args = []
        path_params = self.op_params(operation, "path")
        for param in path_params:
            arg = self.op_param_to_argument(param, allow_required=True)
            args.append(arg)

        return args

    def op_query_arguments(self, operation: dict[str, Any]) -> str:
        """
        Converts query parameters to typer arguments
        """
        args = []
        path_params = self.op_params(operation, "query")
        for param in path_params:
            arg = self.op_param_to_argument(param, allow_required=False)
            args.append(arg)

        return args

    def op_arguments(self, operation: dict[str, Any]) -> str:
        args = []
        args.extend(self.op_path_arguments(operation))
        args.extend(self.op_query_arguments(operation))
        # TODO: body params
        args.extend(self.op_infra_arguments(operation))

        return f"{NL}    " + f",{NL}    ".join(args) + f",{NL}"

    def function_definition(self, node: CommandNode) -> str:
        op = self.operations.get(node.identifier)
        method = op.get(OasField.X_METHOD).upper()

        return f"""

@app.command("{node.command}", help="{self.op_short_help(op)}")
def {to_snake_case(node.identifier)}({self.op_arguments(op)}) -> None:
    '''
    {self.op_long_help(op)}
    '''
    # handler for {node.identifier}: {method} {op.get(OasField.X_PATH)}
    return
"""
